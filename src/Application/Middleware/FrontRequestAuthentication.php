<?php

namespace App\Application\Middleware;

use App\Application\Logger\IntegrationLoggerInterface;
use App\Integrations\Front\V1\Service\ApplicationChannelTrait;
use App\Intrastructure\Persistence\IntegrationRepository;
use App\Settings\SettingsInterface;
use Exception;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Exception\HttpNotFoundException;
use Slim\Exception\HttpUnauthorizedException;

class FrontRequestAuthentication implements MiddlewareInterface
{
    use ApplicationChannelTrait;

    /**
     * @var IntegrationLoggerInterface
     */
    private IntegrationLoggerInterface $logger;

    private SettingsInterface $settings;

    /** @var IntegrationRepository */
    private IntegrationRepository $integrationRepository;

    /**
     * @throws \Exception
     */
    public function __construct(
        IntegrationLoggerInterface $logger,
        SettingsInterface $settings,
        IntegrationRepository $integrationRepository
    ) {
        $this->logger                = $logger;
        $this->settings              = $settings;
        $this->integrationRepository = $integrationRepository;
    }

    /**
     * @inheritDoc
     */
    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {
        $reqBodyStr = $request->getBody()->getContents() ?? '';
        $reqBody    = json_decode($reqBodyStr, true);
        $authHeader = $request->getHeader('Authorization')[0] ?? '';
        $authToken  = str_contains($authHeader, 'Bearer ') ? substr($authHeader, 7) : $authHeader;
        $reqType    = $reqBody['type'] ?? '';       // authorization|verification|message

        if (empty($reqType)) {
            $this->logger->debug('FRONT_AUTH_ERROR', ['msg' => 'Empty request type']);
            throw new HttpUnauthorizedException($request, 'Empty request type');
        }

        if (empty($authToken)) {
            $this->logger->debug('FRONT_AUTH_ERROR', ['msg' => 'Empty authorization header']);
            throw new HttpUnauthorizedException($request, 'Auth token missing');
        }

        // 1. Check auth token (generated by Ringover when integration is created) in request
        if (!$this->checkRingoverToken($authToken)) {
            $this->logger->debug('FRONT_AUTH_ERROR', ['msg' => 'Ringover auth token mismatched']);
            throw new HttpUnauthorizedException($request, 'Ringover auth token mismatched');
        }

        // 2. Continue to check request signature
        if (!$this->checkFrontSignature($request)) {
            $this->logger->debug('FRONT_AUTH_ERROR', ['msg' => 'Wrong signature']);
            throw new HttpUnauthorizedException($request, 'Wrong signature');
        }
        // Peut ajouter l'attribut "use_ivr_num" à la requête, grace à la function isTokenForUsingIvrNum()

        return $handler->handle($request);
    }

    /**
     * Check whether the token is valid and issued by Ringover
     * @param string $authToken
     * @return bool
     */
    private function checkRingoverToken(string $authToken): bool
    {
        // Call Trait function
        return $this->verifyRingoverToken($authToken);
    }

    private function checkFrontSignature(ServerRequestInterface $request): bool
    {
        $reqBodyStr = $request->getBody()->getContents() ?? '';
        $timestamp  = $request->getHeader('x-front-request-timestamp')[0] ?? '';
        $signature  = $request->getHeader('X-Front-Signature')[0] ?? '';
        $baseString = "$timestamp:$reqBodyStr";

        // Get appSecret
        $appSecret = $this->settings->get('integrations')['front']['app_secret'] ?? null;

        if (empty($appSecret)) {
            $this->logger->debug('FRONT_AUTH_ERROR', ['msg' => 'Empty app secret']);
            throw new HttpNotFoundException($request, 'App secret missing');
        }

        // Compare signature with webhook api secert
        $sha256Hash      = hash_hmac('sha256', $baseString, $appSecret, true);
        $encodedSha1Hash = base64_encode($sha256Hash);
        $isGoodSignature = $encodedSha1Hash === $signature;

        if (!$isGoodSignature) {
            $this->logger->debug('FRONT_SIGNATURE_CHECK_FAILED');
        }

        return $isGoodSignature;
    }
}
